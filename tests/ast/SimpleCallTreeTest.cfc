component extends="org.lucee.cfml.test.LuceeTestCase" labels="lcov" displayname="SimpleCallTreeTest" {

	function beforeAll() {
		variables.logLevel = "info";
		variables.logger = new lucee.extension.lcov.Logger(level=variables.logLevel);
		// Use GenerateTestData with test name and ast subfolder
		variables.testDataGenerator = new "../GenerateTestData"(
			testName="SimpleCallTreeTest",
			artifactsSubFolder="ast"
		);

		// Generate test data by running the ast artifacts
		variables.testData = variables.testDataGenerator.generateExlFilesForArtifacts(
			adminPassword: request.SERVERADMINPASSWORD,
			fileFilter: "call-tree-test.cfm"  // Just run the call-tree-test.cfm
		);

		variables.testDir = variables.testData.coverageDir;
	}


	function run() {
		describe("Simple Call Tree Test", function() {

			it("should analyze call tree from call-tree-test.cfm execution", function() {
				// The .exl file should already be generated by generateExlFilesForArtifacts
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) > 0) {
					var exlPath = exlFiles[1];
					variables.logger.debug("Parsing: " & exlPath);

					// Phase 1: Parse .exl file
					var processor = new lucee.extension.lcov.ExecutionLogProcessor( options={logLevel: variables.logLevel} );
					var parseResult = processor.parseExecutionLogs( variables.testDir );
		var jsonFilePaths = parseResult.jsonFilePaths;

					// Phase 2: Extract AST metadata
					var astMetadataGenerator = new lucee.extension.lcov.ast.AstMetadataGenerator( logger=variables.logger );
				var astMetadataPath = astMetadataGenerator.generate( variables.testDir, parseResult.allFiles );

					// Phase 3: Build line coverage
					var lineCoverageBuilder = new lucee.extension.lcov.coverage.LineCoverageBuilder( logger=variables.logger );
					lineCoverageBuilder.buildCoverage( jsonFilePaths, astMetadataPath );

					// Phase 4: Annotate CallTree
					var callTreeAnnotator = new lucee.extension.lcov.coverage.CallTreeAnnotator( logger=variables.logger );
					callTreeAnnotator.annotate( jsonFilePaths, astMetadataPath );

					// Load enriched result from JSON
					var jsonContent = fileRead( jsonFilePaths[1] );
					var result = new lucee.extension.lcov.model.result();
					var data = deserializeJSON( jsonContent );
					for (var key in data) {
						var setter = "set" & key;
						if ( structKeyExists( result, setter ) ) {
							result[setter]( data[key] );
						}
					}

					// Save AST for debugging
					var files = result.getFiles();
					for (var fileId in files) {
						if (structKeyExists(files[fileId], "ast")) {
							// Extract filename from path for better naming
							var sourcePath = files[fileId].path;
							var fileName = listLast(replace(sourcePath, "\", "/", "all"), "/");
							var astPath = variables.testDir & "/ast-" & fileName & "-id" & fileId & ".json";
							fileWrite(astPath, serializeJSON(files[fileId].ast));
							variables.logger.debug("Saved AST for " & sourcePath & " to: " & astPath);

							// Debug: Try extracting functions directly
							var astCallAnalyzer = new lucee.extension.lcov.ast.AstCallAnalyzer( logger=variables.logger );
							var testFunctions = astCallAnalyzer.extractFunctions( files[fileId].ast );
							variables.logger.debug("Direct extraction found " & arrayLen(testFunctions) & " functions");
							for (var func in testFunctions) {
								variables.logger.debug("  - Function: " & func.name & " at pos " & func.startPos & "-" & func.endPos);
							}
						}
					}

					// Check results - this triggers the call tree analysis
					var callTree = result.getCallTree();
					var metrics = result.getCallTreeMetrics();
					variables.logger.debug("Call tree entries: " & structCount(callTree));
					variables.logger.debug("Total blocks: " & metrics.totalBlocks);
					variables.logger.debug("Child time blocks: " & metrics.childTimeBlocks);
					variables.logger.debug("Built-in blocks: " & metrics.builtInBlocks);

					// Save for inspection
					fileWrite(variables.testDir & "/result.json", serializeJSON(result));

					// The call-tree-test.cfm has execution blocks
					expect(metrics.totalBlocks).toBeGT(0, "Should detect blocks from call-tree-test.cfm");
					expect(metrics.childTimeBlocks).toBeGTE(0, "Should detect child time blocks from function calls");
				}
			});
		});
	}
}