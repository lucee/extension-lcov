component extends="org.lucee.cfml.test.LuceeTestCase" labels="lcov" displayname="SimpleCallTreeTest" {

	function beforeAll() {
		// Use GenerateTestData with test name and ast subfolder
		variables.testDataGenerator = new "../GenerateTestData"(
			testName="SimpleCallTreeTest",
			artifactsSubFolder="ast"
		);

		// Generate test data by running the ast artifacts
		variables.testData = variables.testDataGenerator.generateExlFilesForArtifacts(
			adminPassword: request.SERVERADMINPASSWORD,
			fileFilter: "call-tree-test.cfm"  // Just run the call-tree-test.cfm
		);

		variables.testDir = variables.testData.coverageDir;
	}


	function run() {
		describe("Simple Call Tree Test", function() {

			it("should analyze call tree from call-tree-test.cfm execution", function() {
				// The .exl file should already be generated by generateExlFilesForArtifacts
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) > 0) {
					var exlPath = exlFiles[1];
					systemOutput("Parsing: " & exlPath, true);

					// Parse it
					var parser = new lucee.extension.lcov.ExecutionLogParser(verbose: true);
					var result = parser.parseExlFile(
						exlPath: exlPath,
						allowList: [],
						blocklist: []
					);

					// Save AST for debugging BEFORE calling getCallTree() which triggers analysis
					var files = result.getFiles();
					for (var fileId in files) {
						if (structKeyExists(files[fileId], "ast")) {
							// Extract filename from path for better naming
							var sourcePath = files[fileId].path;
							var fileName = listLast(replace(sourcePath, "\", "/", "all"), "/");
							var astPath = variables.testDir & "/ast-" & fileName & "-id" & fileId & ".json";
							fileWrite(astPath, serializeJSON(files[fileId].ast));
							systemOutput("Saved AST for " & sourcePath & " to: " & astPath, true);

							// Debug: Try extracting functions directly
							var astCallAnalyzer = new lucee.extension.lcov.ast.AstCallAnalyzer();
							var testFunctions = astCallAnalyzer.extractFunctions(files[fileId].ast);
							systemOutput("Direct extraction found " & arrayLen(testFunctions) & " functions", true);
							for (var func in testFunctions) {
								systemOutput("  - Function: " & func.name & " at pos " & func.startPos & "-" & func.endPos, true);
							}
						}
					}

					// Debug: Check what's available in the result and call tree
					systemOutput("Result has callTree: " & structKeyExists(result, "callTree"), true);
					systemOutput("Result has getCallTree: " & structKeyExists(result, "getCallTree"), true);

					// Check results - this triggers the call tree analysis
					var callTree = result.getCallTree();
					var metrics = result.getCallTreeMetrics();

					systemOutput("Call tree entries: " & structCount(callTree), true);
					systemOutput("Total blocks: " & metrics.totalBlocks, true);
					systemOutput("Child time blocks: " & metrics.childTimeBlocks, true);
					systemOutput("Built-in blocks: " & metrics.builtInBlocks, true);

					// Save for inspection
					fileWrite(variables.testDir & "/result.json", serializeJSON(result));

					// The call-tree-test.cfm has execution blocks
					expect(metrics.totalBlocks).toBeGT(0, "Should detect blocks from call-tree-test.cfm");
					expect(metrics.childTimeBlocks).toBeGTE(0, "Should detect child time blocks from function calls");
				}
			});
		});
	}
}