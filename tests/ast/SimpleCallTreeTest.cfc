component extends="org.lucee.cfml.test.LuceeTestCase" labels="lcov" displayname="SimpleCallTreeTest" {

	function beforeAll() {
		variables.logLevel = "info";
		variables.logger = new lucee.extension.lcov.Logger(level=variables.logLevel);
		// Use GenerateTestData with test name and ast subfolder
		variables.testDataGenerator = new "../GenerateTestData"(
			testName="SimpleCallTreeTest",
			artifactsSubFolder="ast"
		);

		// Generate test data by running the ast artifacts
		variables.testData = variables.testDataGenerator.generateExlFilesForArtifacts(
			adminPassword: request.SERVERADMINPASSWORD,
			fileFilter: "call-tree-test.cfm"  // Just run the call-tree-test.cfm
		);

		variables.testDir = variables.testData.coverageDir;
	}


	function run() {
		describe("Simple Call Tree Test", function() {

			it("should analyze call tree from call-tree-test.cfm execution", function() {
				// The .exl file should already be generated by generateExlFilesForArtifacts
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) > 0) {
					var exlPath = exlFiles[1];
					variables.logger.debug("Parsing: " & exlPath);

					// Parse it
					var parser = new lucee.extension.lcov.ExecutionLogParser(logLevel: "info");
					var result = parser.parseExlFile(
						exlPath: exlPath,
						allowList: [],
						blocklist: []
					);

					// Save AST for debugging BEFORE calling getCallTree() which triggers analysis
					var files = result.getFiles();
					for (var fileId in files) {
						if (structKeyExists(files[fileId], "ast")) {
							// Extract filename from path for better naming
							var sourcePath = files[fileId].path;
							var fileName = listLast(replace(sourcePath, "\", "/", "all"), "/");
							var astPath = variables.testDir & "/ast-" & fileName & "-id" & fileId & ".json";
							fileWrite(astPath, serializeJSON(files[fileId].ast));
							variables.logger.debug("Saved AST for " & sourcePath & " to: " & astPath);

							// Debug: Try extracting functions directly
							var astCallAnalyzer = new lucee.extension.lcov.ast.AstCallAnalyzer( logger=variables.logger );
							var testFunctions = astCallAnalyzer.extractFunctions( files[fileId].ast );
							variables.logger.debug("Direct extraction found " & arrayLen(testFunctions) & " functions");
							for (var func in testFunctions) {
								variables.logger.debug("  - Function: " & func.name & " at pos " & func.startPos & "-" & func.endPos);
							}
						}
					}

					// Check results - this triggers the call tree analysis
					var callTree = result.getCallTree();
					var metrics = result.getCallTreeMetrics();
					variables.logger.debug("Call tree entries: " & structCount(callTree));
					variables.logger.debug("Total blocks: " & metrics.totalBlocks);
					variables.logger.debug("Child time blocks: " & metrics.childTimeBlocks);
					variables.logger.debug("Built-in blocks: " & metrics.builtInBlocks);

					// Save for inspection
					fileWrite(variables.testDir & "/result.json", serializeJSON(result));

					// The call-tree-test.cfm has execution blocks
					expect(metrics.totalBlocks).toBeGT(0, "Should detect blocks from call-tree-test.cfm");
					expect(metrics.childTimeBlocks).toBeGTE(0, "Should detect child time blocks from function calls");
				}
			});
		});
	}
}