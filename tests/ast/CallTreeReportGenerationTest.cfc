component extends="org.lucee.cfml.test.LuceeTestCase" labels="lcov" displayname="CallTreeReportGenerationTest" {

	function beforeAll() {
		variables.logLevel = "info";
		variables.logger = new lucee.extension.lcov.Logger(level=variables.logLevel);
		// Use GenerateTestData with test name and ast subfolder
		variables.testDataGenerator = new "../GenerateTestData"(
			testName="CallTreeReportGenerationTest",
			artifactsSubFolder="ast"
		);

		// Generate test data by running the ast artifacts
		variables.testData = variables.testDataGenerator.generateExlFilesForArtifacts(
			adminPassword: request.SERVERADMINPASSWORD,
			fileFilter: "cross-file-test.cfm"  // Use cross-file-test to test multiple files
		);

		variables.testDir = variables.testData.coverageDir;
		variables.outputDir = variables.testDataGenerator.getOutputDir();
	}

	function afterAll() {
		// Clean up is handled by GenerateTestData if needed
	}

	function run() {
		describe("Call Tree Report Generation", function() {

			it("should generate HTML report with call tree data", function() {
				// The .exl file should already be generated by generateExlFilesForArtifacts
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) == 0) {
					throw("No .exl files found in " & variables.testDir);
				}

				// Generate HTML report (runs full pipeline including CallTree annotation)
				var htmlOutputDir = variables.testDataGenerator.getOutputDir( "html" );
				variables.logger.debug( "Creating HTML output directory: " & htmlOutputDir );

				var htmlResult = lcovGenerateHtml(
					executionLogDir: variables.testDir,
					outputDir: htmlOutputDir
				);

				// Check that HTML files were created
				var htmlDir = variables.outputDir & "/html";
				var indexPath = htmlDir & "/index.html";

				expect(directoryExists(htmlDir)).toBeTrue("HTML output directory should exist at: " & htmlDir);
				expect(fileExists(indexPath)).toBeTrue("index.html should exist at: " & indexPath);

				// Read the index.html to check for call tree columns
				var indexHtml = fileRead(indexPath);

				// Check for Child Time column header
				expect(indexHtml).toInclude("Child Time", "HTML should have Child Time column in file: " & indexPath);

				// Load the enriched result from the JSON files written to OUTPUT directory
				var jsonFiles = directoryList(htmlDir, false, "array", "*.json");
				var resultJsonFile = "";
				for (var jsonFile in jsonFiles) {
					if (!findNoCase("ast-metadata", jsonFile) && !findNoCase("index.json", jsonFile)) {
						resultJsonFile = jsonFile;
						break;
					}
				}

				expect(resultJsonFile != "").toBeTrue("Should find result JSON file in output directory: " & htmlDir & " (found: " & arrayToList(jsonFiles) & ")");

				// Read and verify JSON structure has CallTree data
				var jsonContent = deserializeJSON(fileRead(resultJsonFile));
				expect(structKeyExists(jsonContent, "callTree")).toBeTrue("JSON should contain callTree in " & resultJsonFile);
				expect(structKeyExists(jsonContent, "callTreeMetrics")).toBeTrue("JSON should contain callTreeMetrics" & resultJsonFile);

				// Verify call tree metrics structure
				var metrics = jsonContent.callTreeMetrics;
				expect(structKeyExists(metrics, "totalBlocks")).toBeTrue("Should have totalBlocks in " & resultJsonFile);
				expect(structKeyExists(metrics, "childTimeBlocks")).toBeTrue("Should have childTimeBlocks in " & resultJsonFile);
				expect(structKeyExists(metrics, "builtInBlocks")).toBeTrue("Should have builtInBlocks in " & resultJsonFile);
			});

			it("should generate separate HTML files when separateFiles is true", function() {
				// Use the actual .exl file with real call tree data
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file in: " & variables.testDir);

				if (arrayLen(exlFiles) == 0) {
					return; // Skip if no files
				}

				// Create output directory for separate HTML files
				var htmlOutputDir = variables.testDataGenerator.getOutputDir( "html-separate" );
				variables.logger.debug( "Creating HTML output directory for separate files: " & htmlOutputDir );

				// Generate HTML report with separateFiles: true
				variables.logger.debug("Generating HTML with separateFiles: true");
				variables.logger.debug("  executionLogDir: " & variables.testDir);
				variables.logger.debug("  outputDir: " & htmlOutputDir);
				var htmlResult = lcovGenerateHtml(
					executionLogDir: variables.testDir,
					outputDir: htmlOutputDir,
					options: {
						separateFiles: true,  // This should create a separate HTML file for each source file
						logLevel: "info"  // Enable verbose output to see what's happening
					}
				);

				// Check that HTML files were created
				expect(fileExists(htmlOutputDir & "/index.html")).toBeTrue("index.html should exist in [" & htmlOutputDir & "]");

				// Check that we have separate HTML files for each source file
				var htmlFiles = directoryList(htmlOutputDir, false, "path", "*.html");

				// Should have at least 2 files: index.html plus one for call-tree-test.cfm
				expect(arrayLen(htmlFiles)).toBeGT(1, "Should have multiple HTML files with separateFiles: true in [" & htmlOutputDir & "]");

				// Count non-index HTML files
				var sourceFileCount = 0;
				for (var htmlFile in htmlFiles) {
					if (findNoCase("index", getFileFromPath(htmlFile)) == 0) {
						sourceFileCount++;
					}
				}

				expect(sourceFileCount).toBeGT(0, "Should have at least one source file HTML in [" & htmlOutputDir & "]");

				// Verify the separate files contain call tree data
				for (var htmlFile in htmlFiles) {
					if (findNoCase("index", getFileFromPath(htmlFile)) == 0) {
						var fileHtml = fileRead(htmlFile);
						// Check for call tree columns in individual files
						if (len(fileHtml) > 100) {
							expect(fileHtml).toInclude("Child Time", "Separate file should have Child Time column in [" & htmlFile & "]");
						}
					}
				}
			});

			it("should track child time blocks correctly", function() {
				// Use the actual .exl file with real call tree data
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file in: " & variables.testDir);

				if (arrayLen(exlFiles) == 0) {
					return; // Skip if no files
				}

				// Run full pipeline to generate CallTree
				var processor = new lucee.extension.lcov.ExecutionLogProcessor( options={logLevel: variables.logLevel} );
				var parseResult = processor.parseExecutionLogs( variables.testDir );
		var jsonFilePaths = parseResult.jsonFilePaths;
				var astMetadataGenerator = new lucee.extension.lcov.ast.AstMetadataGenerator( logger=variables.logger );
				var astMetadataPath = astMetadataGenerator.generate( variables.testDir, parseResult.allFiles );
				var lineCoverageBuilder = new lucee.extension.lcov.coverage.LineCoverageBuilder( logger=variables.logger );
				lineCoverageBuilder.buildCoverage( jsonFilePaths, astMetadataPath );
				var callTreeAnnotator = new lucee.extension.lcov.coverage.CallTreeAnnotator( logger=variables.logger );
				callTreeAnnotator.annotate( jsonFilePaths, astMetadataPath );

				// Load enriched result from JSON
				var jsonFile = jsonFilePaths[1]; // Get first non-ast-metadata JSON
				for (var path in jsonFilePaths) {
					if (!findNoCase("ast-metadata", path)) {
						jsonFile = path;
						break;
					}
				}

				var jsonData = deserializeJSON(fileRead(jsonFile));

				// Verify call tree calculations
				expect(structKeyExists(jsonData, "callTreeMetrics")).toBeTrue("Result should have call tree metrics");
				var metrics = jsonData.callTreeMetrics;
				expect(structCount(metrics)).toBeGT(0, "Metrics should not be empty");

				// Check the metrics structure
				expect(structKeyExists(metrics, "totalBlocks")).toBeTrue("Should have totalBlocks");
				expect(structKeyExists(metrics, "childTimeBlocks")).toBeTrue("Should have childTimeBlocks");
				expect(structKeyExists(metrics, "builtInBlocks")).toBeTrue("Should have builtInBlocks");

				// Verify we have blocks tracked
				expect(metrics.totalBlocks).toBeGT(0, "Should have tracked blocks");

				// Verify call tree structure
				expect(structKeyExists(jsonData, "callTree")).toBeTrue("Should have callTree");
				var callTree = jsonData.callTree;
				expect(structCount(callTree)).toBeGT(0, "Call tree should have entries");
			});

		});
	}
}