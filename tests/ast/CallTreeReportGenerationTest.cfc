component extends="org.lucee.cfml.test.LuceeTestCase" labels="lcov" displayname="CallTreeReportGenerationTest" {

	function beforeAll() {
		// Use GenerateTestData with test name and ast subfolder
		variables.testDataGenerator = new "../GenerateTestData"(
			testName="CallTreeReportGenerationTest",
			artifactsSubFolder="ast"
		);

		// Generate test data by running the ast artifacts
		variables.testData = variables.testDataGenerator.generateExlFilesForArtifacts(
			adminPassword: request.SERVERADMINPASSWORD,
			fileFilter: "cross-file-test.cfm"  // Use cross-file-test to test multiple files
		);

		variables.testDir = variables.testData.coverageDir;
		variables.outputDir = variables.testDir;

		if (!directoryExists(variables.outputDir)) {
			directoryCreate(variables.outputDir);
		}
	}

	function afterAll() {
		// Clean up is handled by GenerateTestData if needed
	}

	function run() {
		describe("Call Tree Report Generation", function() {

			it("should generate HTML report with call tree data", function() {
				// The .exl file should already be generated by generateExlFilesForArtifacts
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) == 0) {
					throw("No .exl files found in " & variables.testDir);
				}

				var exlPath = exlFiles[1];

				// Parse the execution log
				var parser = new lucee.extension.lcov.ExecutionLogParser(verbose: false);
				var result = parser.parseExlFile(
					exlPath: exlPath,
					allowList: [],
					blocklist: []
				);

				// Verify call tree data was generated
				var callTree = result.getCallTree();

				// Debug: Write the full result to see what we got
				var debugPath = variables.outputDir & "/debug-result.json";
				fileWrite(debugPath, serializeJSON(result));
				systemOutput("Debug result written to: " & debugPath, true);
				systemOutput("CallTree has " & structCount(callTree) & " entries", true);

				expect(structCount(callTree)).toBeGT(0, "Result should have call tree data");

				var metrics = result.getCallTreeMetrics();
				expect(structCount(metrics)).toBeGT(0, "Result should have call tree metrics");

				// Check call tree metrics
				expect(structKeyExists(metrics, "totalBlocks")).toBeTrue("Should have totalBlocks");
				expect(structKeyExists(metrics, "childTimeBlocks")).toBeTrue("Should have childTimeBlocks");
				expect(structKeyExists(metrics, "builtInBlocks")).toBeTrue("Should have builtInBlocks");

				// Create output directory for HTML
				var htmlOutputDir = variables.outputDir & "/html";
				systemOutput("Creating HTML output directory: " & htmlOutputDir, true);	
				if (!directoryExists(htmlOutputDir)) {
					directoryCreate(htmlOutputDir, true);
				}

				// Generate HTML report using lcovGenerateHtml function
				var htmlResult = lcovGenerateHtml(
					executionLogDir: variables.testDir,
					outputDir: htmlOutputDir
				);

				// Check that HTML files were created
				expect(directoryExists(variables.outputDir & "/html")).toBeTrue("HTML output directory should exist");
				expect(fileExists(variables.outputDir & "/html/index.html")).toBeTrue("index.html should exist");

				// Read the index.html to check for call tree columns
				var indexHtml = fileRead(variables.outputDir & "/html/index.html");

				// Check for Child Time column header
				expect(indexHtml).toInclude("Child Time", "HTML should have Child Time column");

				// Generate JSON report
				var jsonPath = variables.outputDir & "/result.json";
				fileWrite(jsonPath, serializeJSON(result));
				expect(fileExists(jsonPath)).toBeTrue("JSON file should be created");

				// Read and verify JSON structure
				var jsonContent = deserializeJSON(fileRead(jsonPath));
				expect(structKeyExists(jsonContent, "callTree")).toBeTrue("JSON should contain callTree");
				expect(structKeyExists(jsonContent, "callTreeMetrics")).toBeTrue("JSON should contain callTreeMetrics");

				// Skip CallTreeReporter tests for now - focus on JSON validation
				// The CallTreeReporter is a separate component that can be tested independently
			});

			it("should generate separate HTML files when separateFiles is true", function() {
				// Use the actual .exl file with real call tree data
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) == 0) {
					return; // Skip if no files
				}

				var exlPath = exlFiles[1];

				// Parse the execution log
				var parser = new lucee.extension.lcov.ExecutionLogParser(verbose: false);
				var result = parser.parseExlFile(
					exlPath: exlPath,
					allowList: [],
					blocklist: []
				);

				// Create output directory for separate HTML files
				var htmlOutputDir = variables.outputDir & "/html-separate";
				systemOutput("Creating HTML output directory for separate files: " & htmlOutputDir, true);
				if (!directoryExists(htmlOutputDir)) {
					directoryCreate(htmlOutputDir, true);
				}

				// Generate HTML report with separateFiles: true
				systemOutput("Generating HTML with separateFiles: true", true);
				systemOutput("  executionLogDir: " & variables.testDir, true);
				systemOutput("  outputDir: " & htmlOutputDir, true);
				var htmlResult = lcovGenerateHtml(
					executionLogDir: variables.testDir,
					outputDir: htmlOutputDir,
					options: {
						separateFiles: true,  // This should create a separate HTML file for each source file
						verbose: false  // Enable verbose output to see what's happening
					}
				);

				// Check that HTML files were created
				expect(fileExists(htmlOutputDir & "/index.html")).toBeTrue("index.html should exist");

				// Check that we have separate HTML files for each source file
				var htmlFiles = directoryList(htmlOutputDir, false, "path", "*.html");

				// Should have at least 2 files: index.html plus one for call-tree-test.cfm
				expect(arrayLen(htmlFiles)).toBeGT(1, "Should have multiple HTML files with separateFiles: true");

				// Count non-index HTML files
				var sourceFileCount = 0;
				for (var htmlFile in htmlFiles) {
					if (findNoCase("index", getFileFromPath(htmlFile)) == 0) {
						sourceFileCount++;
					}
				}

				expect(sourceFileCount).toBeGT(0, "Should have at least one source file HTML");

				// Verify the separate files contain call tree data
				for (var htmlFile in htmlFiles) {
					if (findNoCase("index", getFileFromPath(htmlFile)) == 0) {
						var fileHtml = fileRead(htmlFile);
						// Check for call tree columns in individual files
						if (len(fileHtml) > 100) {
							expect(fileHtml).toInclude("Child Time", "Separate file should have Child Time column");
						}
					}
				}
			});

			it("should track child time blocks correctly", function() {
				// Use the actual .exl file with real call tree data
				var exlFiles = directoryList(variables.testDir, false, "path", "*.exl");
				expect(arrayLen(exlFiles)).toBeGT(0, "Should have generated .exl file");

				if (arrayLen(exlFiles) == 0) {
					return; // Skip if no files
				}

				var exlPath = exlFiles[1];

				var parser = new lucee.extension.lcov.ExecutionLogParser(verbose: false);
				var result = parser.parseExlFile(
					exlPath: exlPath,
					allowList: [],
					blocklist: []
				);

				// Write result to JSON for inspection
				var jsonPath = variables.outputDir & "/child-time-test.json";
				fileWrite(jsonPath, serializeJSON(result));

				// Verify call tree calculations
				var metrics = result.getCallTreeMetrics();
				expect(structCount(metrics)).toBeGT(0, "Result should have call tree metrics");

				// Check the metrics structure
				expect(structKeyExists(metrics, "totalBlocks")).toBeTrue("Should have totalBlocks");
				expect(structKeyExists(metrics, "childTimeBlocks")).toBeTrue("Should have childTimeBlocks");
				expect(structKeyExists(metrics, "builtInBlocks")).toBeTrue("Should have builtInBlocks");

				// Verify we have blocks tracked
				expect(metrics.totalBlocks).toBeGT(0, "Should have tracked blocks");

				// Verify call tree structure
				var callTree = result.getCallTree();
				expect(structCount(callTree)).toBeGT(0, "Call tree should have entries");
			});

		});
	}
}